<!doctype html>
<html lang="en">
<head>
  <title>GitCity | 3D Visualization</title>
  <meta charset="utf-8">
  <link rel="stylesheet" href="css/style.css"/>
</head>
<body style="margin: 0;" onLoad = "init()">
  <link rel="stylesheet" href="https://code.jquery.com/ui/1.10.4/themes/smoothness/jquery-ui.css">
  <script src="https://code.jquery.com/jquery-1.10.2.js"></script>
  <script src="https://code.jquery.com/ui/1.10.4/jquery-ui.js"></script>
  <script src="js/three.min.js"></script>
  <!-- <script src="js/three-everything.js"></script> -->
  <script src="js/OrbitControls.js"></script>
  <script src="fonts/helvetiker_regular.typeface.js"></script>
  <script src="data/commitData.js"></script>
  <script src="data/contributorInfoData.js"></script>
  <script src="data/initialCommitData.js"></script>
  <!-- ---------------- Custom Shader Code ------------------------ -->
<script id="vertexGlowShader" type="x-shader/x-vertex">
varying vec3 vNormal;
void main() 
{
    vNormal = normalize( normalMatrix * normal );
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>

<script id="fragmentGlowShader" type="x-shader/x-vertex"> 
uniform vec3 glowColor;
varying vec3 vNormal;
void main() 
{
	float intensity = pow( 0.7 - dot( vNormal, vec3( 0.0, 0.0, 1.0 ) ), 4.0 ); 
	vec3 glow = glowColor * intensity;
    gl_FragColor = vec4( glow, 1.0 ) * intensity;
}
</script>
<!-- ----------------------------------------------------------- -->

	<script type="x-shader/x-vertex" id="vertexShader">

		varying vec3 vWorldPosition;

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	</script>

	<script type="x-shader/x-fragment" id="fragmentShader">

		uniform vec3 topColor;
		uniform vec3 bottomColor;
		uniform float offset;
		uniform float exponent;

		varying vec3 vWorldPosition;

		void main() {

			float h = normalize( vWorldPosition + offset ).y;
			gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( h, exponent ), 0.0 ) ), 1.0 );

		}

	</script>


  <script>
	// mozilla variables
	
	//var langSects = ["Python", "PHP", "JavaScript", "Rust", "None", "Perl", "C", "CSS", "Java", "Shell", "C++", "Ruby", "D", "ActionScript", "Objective-C", "Puppet", "Bro", "Go"];
	/*
	["Python", #588C7E
	"PHP", #F2E394
	"JavaScript", #F2AE72
	"Rust", #D96459
	"None", #8C4646
	"Perl", #08A5AC
	"C", #32BE72
	"CSS", #F74C4D
	"Java", #FB9D34
	"Shell", #E2E3E8
	"C++", #F5BC55
	"Ruby", #EE615A
	"D", #F3F5F2
	"ActionScript", #DDC388
	"Objective-C", #E07323
	"Puppet", #43261C
	"Bro", #1FD1FF
	"Go", #6DD965]
	*/
	var langColors = {"Python": 0x588C7E, "PHP": 0xF2E394, "JavaScript": 0xF2AE72, "Rust": 0xD96459, "None": 0x8C4646, "Perl": 0x08A5AC, "C": 0x32BE72, "CSS": 0xF74C4D, "Java": 0xFB9D34, "Shell": 0xE2E3E8, "C++": 0xF5BC55, "Ruby": 0xEE615A, "D": 0xF3F5F2, "ActionScript": 0xDDC388, "Objective-C": 0xE07323, "Puppet": 0x43261C, "Bro": 0x1FD1FF, "Go": 0x6DD965};
	
	var langSects = {"Python": 0, "PHP": 0.349, "JavaScript": 0.698, "Rust": 1.047, "None": 1.396, "Perl": 1.745, "C": 2.094, "CSS": 2.443, "Java": 2.792, "Shell": 3.141, "C++": 3.49, "Ruby": 3.839, "D": 4.188, "ActionScript": 4.537, "Objective-C": 4.886, "Puppet": 5.235, "Bro": 5.584, "Go": 5.933};
		
	var projectLanguages = ["Python", "PHP", "JavaScript", "Rust", "None", "Perl", "C", "CSS", "Java", "Shell", "C++", "Ruby", "D", "ActionScript", "Objective-C", "Puppet", "Bro", "Go"];
	
	var yearColorLookup = {2007: 0xFCEECB, 2008: 0xEBD3AD, 2009: 0xAE8663, 2010: 0xFCEECB, 2011: 0xEBD3AD, 2012: 0xAE8663, 2013: 0xFCEECB, 2014: 0xEBD3AD	};
	
	var monthLookup = {"01": "Jan", "02": "Feb", "03": "Mar", "04": "Apr", "05": "May", "06": "Jun", "07": "Jul", "08": "Aug", "09": "Sep", "10": "Oct", "11": "Nov", "12": "Dec"};
	
	
    // Set up the scene, camera, and renderer as global variables.
	var containerUI, infoUI;
    var scene, camera, renderer, light, controls, composer;
	var sun;
	var initiationFlag = true;
	var clock = new THREE.Clock();

	var selectedObject;
	var angle = 0, angleSun = 0, angleContributor = 0,
	//STEP = (2*Math.PI) / langSects.length,
	STEP = 0.05,
	STEPSUN = (2*Math.PI) / 20,
	CONTRIBUTORSTEP = 0.3,
	RINGRADIUS = 30,
	ringTimeLine = [];
	var cylinderObj = new THREE.Object3D();
	var ringNum = 0, ringNumInitial = 0, repoCounter = 0;
	var repoAddedToScene = [];
	var cylinderArray = {};
	var cylinderArray2 = [];
	var contributorNames = [];
	var projectNames = [];
	var HEIGHT_NORMALIZER = 10;
	var HEIGHT_COMMITS = true;
	var HEIGHT_LINESOFCODE = false;
	// total rings currently hard-coded for each month from Jan 2007 till Dec 2014 (12 * 8)
	var TOTAL_RINGS = 87;
	var RING_OPACITY = 0.7;
	var PROJECT_OPACITY = 1;
	var USER_OPACITY = 0.8;
	var DISABLE_OPACITY = 0;
	
	var particles = [];
	var RING_VIEW = false;
	var MAIN_VIEW = false;
	var USER_VIEW = false;
	var PROJECT_VIEW = false;
	var GO_TO_DATE = false;
	var jumpToDate = "0000-00-00";
	var currentTimePeriod = "0000-00-00";
	var textProjectInfoArray = [];
	var textRingIds = [];
	var textYears = [];
	var MOVE_ORBIT_CONTROLS = false;	
	
	var INTRO_SEQUENCE = true;
		
	var ground;
	var zoomOutDistance = [2500, 2500, 500];
	
    
	
	function onWindowResize() {
		var WIDTH = window.innerWidth,
			HEIGHT = window.innerHeight;
		renderer.setSize(WIDTH, HEIGHT);
		camera.aspect = WIDTH / HEIGHT;
		camera.updateProjectionMatrix();
		
	}
	
	function contains(a, obj) {
		var i = a.length;
		while (i--) {
		   if (a[i] == obj) {
			   return true;
		   }
		}
		return false;
	}
    // Sets up the scene.
    function init() {
	
				containerUI = document.createElement( 'div' );
				document.body.appendChild(containerUI);
				
				infoUI = document.getElementById( "infoUI" );
				infoUI.innerHTML = 'Github City';
				containerUI.appendChild( infoUI );
				
				infoUI1 = document.getElementById( 'infoUI1' );
				infoUI1.innerHTML = 'Double click to select or de-select';
				containerUI.appendChild( infoUI1 );
	
		// Create the scene and set the scene size.
		scene = new THREE.Scene();
		var WIDTH = window.innerWidth,
		  HEIGHT = window.innerHeight;

		// Create a renderer and add it to the DOM.
		renderer = new THREE.WebGLRenderer({antialias:true});
		renderer.setSize(WIDTH, HEIGHT);
		document.body.appendChild(renderer.domElement);

		// Create a camera, zoom it out from the model a bit, and add it to the scene.
		camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 80000);
		camera.position.set(70,0,5200);
		//camera.position.y = 100;
		//camera.lookAt(new THREE.Vector3(0, 0, 0));
		scene.add(camera);

		// Create an event listener that resizes the renderer with the browser window.
		window.addEventListener('resize', onWindowResize);

		// Set the background color of the scene.
		//renderer.setClearColorHex(0x333F47, 1);
		renderer.setClearColorHex(0xffffff, 1);
		renderer.shadowMapEnabled = true;
		renderer.shadowMapSoft = true;

		// Create a light, set its position, and add it to the scene.
		spotLight1 = new THREE.SpotLight(0xffffff);
		spotLight1.position.set(0,100,-3000);
		spotLight1.castShadow = true;
		
		spotLight2 = new THREE.SpotLight(0xffffff);
		spotLight2.position.set(-500,100,-3000);
		spotLight2.castShadow = true;
		
		//scene.add(spotLight1);
		//scene.add(spotLight2);
		
		//Load in the mesh and add it to the scene.
		//var loader = new THREE.JSONLoader();
		//loader.load( "models/sun.js", function(geometry){
		//var material = new THREE.MeshLambertMaterial({color: 0x55B663});
		//mesh = new THREE.Mesh(geometry, material);
		//scene.add(mesh);
		//});
		var sphereGeo = new THREE.SphereGeometry(100, 32, 16);
    

	// create custom material from the shader code above
	//   that is within specially labeled script tags
	var haloMaterial = new THREE.ShaderMaterial( 
	{
	    uniforms: { 
			glowColor: { type: "c", value: new THREE.Color(0xffff00) }
		},
		vertexShader:   document.getElementById( 'vertexGlowShader'   ).textContent,
		fragmentShader: document.getElementById( 'fragmentGlowShader' ).textContent,
		side: THREE.BackSide,
		blending: THREE.AdditiveBlending,
		transparent: true
	}   );
		
	var haloGeometry = new THREE.SphereGeometry( 550, 32, 32 );
	var halo = new THREE.Mesh( haloGeometry, haloMaterial );
		//halo.position.set(0,1000,-20000);
		//0xF36E09
		sun = new THREE.Mesh( new THREE.SphereGeometry( 500, 32, 32 ), new THREE.MeshBasicMaterial( {color: 0xFF0000, transparent: false, opacity: 0.25} ) );
		sun.position.set(0,100,-36000);
		//light.add( sun );
		
				//changeView('MAIN_VIEW');
		
		hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
		//hemiLight.color.setHSL( 0.6, 1, 0.6 );
		hemiLight.color.set( 0xf7b763 );
		//hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
		hemiLight.position.set( 0, 500, 0 );
		//scene.add( hemiLight );
		scene.add(new THREE.AmbientLight(0x404040));
		
		dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
		dirLight.position.set(0,50,-4000);

				dirLight.castShadow = true;
				dirLight.shadowMapWidth = 2048;
				dirLight.shadowMapHeight = 2048;
				
				var d = 50;
				dirLight.shadowCameraLeft = -d * 70;
				dirLight.shadowCameraRight = d * 70;
				dirLight.shadowCameraTop = d;
				dirLight.shadowCameraBottom = -d;

				dirLight.shadowCameraFar = 7000;
				dirLight.shadowBias = -0.0001;
				dirLight.shadowDarkness = 0.10;
				//dirLight.shadowCameraVisible = true;
				//sun.add( halo );
				dirLight.add( sun );
		scene.add( dirLight );
		
		// GROUND
		var groundGeo = new THREE.PlaneGeometry( 100000, 100000 );
		//var groundMat = new THREE.MeshPhongMaterial( { ambient: 0xffffff, color: 0xffffff, specular: 0x050505 } );
		var groundMat = new THREE.MeshBasicMaterial( { color: 0xfefefe } );
		//groundMat.color.setHSL( 0.095, 1, 0.75 );

		ground = new THREE.Mesh( groundGeo, groundMat );
		ground.rotation.x = -Math.PI/2;
		ground.position.y = -80;
		scene.add( ground );
				ground.receiveShadow = true;
		
		// SKYDOME
		//scene.fog = new THREE.Fog( 0xffffff, 1, 5000 );
		//scene.fog.color.setHSL( 0.6, 0, 1 );
		
		var vertexShader = document.getElementById( 'vertexShader' ).textContent;
		var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
		var uniforms = {
			topColor: 	 { type: "c", value: new THREE.Color( 0x1a7df3 ) },
			bottomColor: { type: "c", value: new THREE.Color( 0xd04109 ) },
			offset:		 { type: "f", value: 33 },
			exponent:	 { type: "f", value: 1 }
		}
		//uniforms.topColor.value.copy( hemiLight.color );
		uniforms.bottomColor.value.copy( hemiLight.color );

		//scene.fog.color.copy( uniforms.bottomColor.value );
		//SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)
		var skyGeo = new THREE.SphereGeometry( 40000, 32, 15, 0, Math.PI );
		var skyMat = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide } );
		var sky = new THREE.Mesh( skyGeo, skyMat );
		sky.rotation.x = -Math.PI / 2;
		scene.add( sky );
		
		//scene.fog = new THREE.FogExp2( 0xd0e0f0, 0.0025 );
		//scene.fog = new THREE.FogExp2( 0x111111, 0.002 );


		// plane
		plane = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000, 30), new THREE.MeshBasicMaterial({wireframe: true, color: 'white', visible: false}));
		//plane.overdraw = false;
		//plane.receiveShadow = true;
		plane.rotation.x = - 90 * Math.PI / 180;
		scene.add(plane);
		selectedObject = plane;
		
		cylinderGeometry = new THREE.CylinderGeometry(1, 1, 1, 12,6);
		cylinderGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0.5, 0 ) );
		
		ringStep = 0;
		var month = 1, year = 2007;
		

		var buildingTexture = new THREE.Texture( generateTexture() );
		buildingTexture.anisotropy = renderer.getMaxAnisotropy();
		buildingTexture.needsUpdate = true;

		for(var i = 0; i < TOTAL_RINGS; i++)
		{
			//0x159A8F
			
			var color = yearColorLookup[year];
			
			var innerRadius = ringStep + 1;
			var outerRadius = ringStep += RINGRADIUS;
			ring = new THREE.Mesh( new THREE.RingGeometry( innerRadius, outerRadius, 99 ), new THREE.MeshBasicMaterial( { color: color, transparent: true, opacity: 0.5 } ) );
							
			//ring.rotation.x = - 90 * Math.PI / 180;
			ring.position.y = 0.2;
			ring.receiveShadow = true;
			ring.outerRadius = ringStep;
			ring.actualColor = color;
			ring.yearColor = color;
			ring.type = 'ringMonth';
			ring.fadeOut = false;
					
			if(month < 10)
			{
				ring.id = year + '-0' + month++;
			}
			else
			{
				ring.id = year + '-' + month++;
			}
			
			if(month > 12)
			{				
				var textYear = new THREE.TextGeometry( year, { 
					size: 32,
					height: 8,
					curveSegments: 2,
					font: "helvetiker" });
				var textColor = 0x7C1771;
				var textMaterial = new THREE.MeshBasicMaterial( { color: textColor, transparent: true } );
				text = new THREE.Mesh( textYear, textMaterial );
				text.actualColor = textColor;
				text.rotation.x = Math.PI / 4;
				//text.rotation.y = Math.PI / 4;
				//text.rotation.z = -Math.PI;
				//text.position = obj.position.clone();
				text.position.x = 100;
				text.position.y = -(ringStep - 6 * RINGRADIUS);
				//text.position.y = obj.position.z + 10;
				text.id = year;
				text.type = 'text';
				text.fadeOut = false;
				textYears.push(text);
				//plane.add(text);
				
				
				month = 1;
				year += 1;
			}
			
			
			var textRingId = new THREE.TextGeometry( monthLookup[ring.id.substring(5,8)], { 
				size: 16,
				height: 4,
				curveSegments: 2,
				font: "helvetiker" });

			var textColor = 0x7C1771;
			var textMaterial = new THREE.MeshBasicMaterial( { color: textColor, transparent: true } );
			text = new THREE.Mesh( textRingId, textMaterial );
			text.actualColor = textColor;
			
			text.rotation.x = Math.PI / 4;
			//text.rotation.y = Math.PI / 4;
			//text.rotation.z = Math.PI;
			//text.position = obj.position.clone();
			text.position.y = -(ringStep - RINGRADIUS / 2);
			//text.position.y = obj.position.z + 10;
			text.id = ring.id;
			text.type = 'text';
			text.fadeOut = false;
			text.scale.x = text.scale.y = 1.3;
			textRingIds.push(text);
			//ring.add(text);
			
			ringTimeLine.push(ring);
			
			var dateStreak = 0;
			for(var j=0; j < initialRepoData.length; j++)
			{
				if(initialRepoData[j].created_at.substring(0,7) == ring.id)
				{
					//if((j < initialRepoData.length - 1) && (initialRepoData[j].created_at == initialRepoData[j + 1].created_at))
					if((j > 0) && (initialRepoData[j].created_at == initialRepoData[j - 1].created_at))
					{
						//console.log(2 * Math.PI * initialRepoData[j].created_at.substring(8,10)/31);
						angle = 2 * Math.PI * initialRepoData[j].created_at.substring(8,10)/31 + 0.15 * ++dateStreak;
						
						j<20?angle*=1:angle*=0.1;
					}
					else
					{
						dateStreak = 0;
						angle = 2 * Math.PI * initialRepoData[j].created_at.substring(8,10)/31;
					}
					//angle = langSects[initialRepoData[j].language];
									
					var color1 = langColors[initialRepoData[j].language];
					
					var cylinder2 = new THREE.Mesh(cylinderGeometry, new THREE.MeshPhongMaterial({color: color1, wireframe: false, transparent: true, opacity: PROJECT_OPACITY}));
					cylinder2.name = initialRepoData[j].repo;	
					projectNames.push(cylinder2.name);					
					
					cylinder2.scale.x = cylinder2.scale.z = 10;
					//cylinder2.scale.x = cylinder2.scale.z = Math.floor( Math.random() * 10);
					
					if(cylinder2.position.x > 0)
						cylinder2.position.x = (ringStep + RINGRADIUS / 2) * Math.cos(angle);
					else
						cylinder2.position.x = (ringStep - RINGRADIUS / 2) * Math.cos(angle);
					//console.log(cylinder2.position.x);
					
					if(cylinder2.position.y > 0)
						cylinder2.position.y = (ringStep + RINGRADIUS / 2) * Math.sin(angle);					
					else
						cylinder2.position.y = (ringStep - RINGRADIUS / 2) * Math.sin(angle);					
						
					cylinder2.position.z = 0;
					if(HEIGHT_LINESOFCODE)
					{
						cylinder2.height = HEIGHT_NORMALIZER + (initialRepoData[j].initialSize) / 100;
					}
					else if(HEIGHT_COMMITS)
					{
						cylinder2.height = HEIGHT_NORMALIZER + 1;
					}
					cylinder2.rotation.x = 90 * Math.PI / 180;
					
					//cylinder2.scale.y = cylinder2.height;
					cylinder2.castShadow = true;
					cylinder2.receiveShadow = true;
					
					cylinder2.addedToScene = false;
					cylinder2.language = initialRepoData[j].language;					
					cylinder2.actualColor = color1;
					cylinder2.type = 'project';
					cylinder2.fadeOut = false;
					cylinder2.created_at = initialRepoData[j].created_at;
					cylinder2.allContributors = [];
					
					cylinderArray2.push(cylinder2);	
					cylinderArray[initialRepoData[j].repo] = cylinder2;	
					ring.add( cylinder2 );								
					
					//console.log(ring.children.length);				
				}
			}
		}
		ringStep = 0;
		//scene.add( cylinderObj );
		
		//add name on top of each cylinder
		cylinderArray2.forEach(function(project) {		

			var ring = project.parent;
			var textProjectInfo = new THREE.TextGeometry( project.name, { 
				size: 4,
				height: 1,
				curveSegments: 2,
				font: "helvetiker" });
			
			var textColor = 0x7C1771;
			var textMaterial = new THREE.MeshBasicMaterial( { color: textColor, transparent: true } );
			text = new THREE.Mesh( textProjectInfo, textMaterial );
			text.actualColor = textColor;
			
			text.rotation.x = Math.PI / 4;
			//text.position = project.position.clone();
			//console.log(project.position);
			text.projectName = project.name;
			text.position.x = project.position.x;
			text.position.y = project.position.y;
			text.position.z = project.height + 5;
			text.type = 'text';
			textProjectInfoArray.push(text);
			project.textObject = text;
			ring.add(text);
			
		});
		
		addContributors();
		
		var material = new THREE.MeshBasicMaterial({wireframe: true, color: 0x404040, opacity: RING_OPACITY, transparent: true});
		var circleGeometry = new THREE.CircleGeometry( 0.5, 31 );				
		circle = new THREE.Mesh( circleGeometry, material );
		circle.rotation.x = - 90 * Math.PI / 180;
		circle.position.y = 0;
		circle.visible = false;
		scene.add(circle);
		
					
		// Picking stuff

		projector = new THREE.Projector();
		mouseVector = new THREE.Vector3();

		// User interaction
		window.addEventListener( 'mousemove', onMouseMove, false );
		window.addEventListener( 'resize', onWindowResize, false );
		window.addEventListener( 'dblclick', onMouseDown, false );

		function onMouseDown( e ) {

			mouseVector.x = 2 * (e.clientX / WIDTH) - 1;
			mouseVector.y = 1 - 2 * ( e.clientY / HEIGHT );

			var raycaster = projector.pickingRay( mouseVector.clone(), camera ),
				intersects = raycaster.intersectObjects( selectedObject.children );

			
			//for( var i = 0; i < intersects.length; i++ ) {
			if(intersects.length > 0)
			{
				
				//selectedObject.children.forEach(function( ring ) {
				//	ring.material.opacity = 0.1;
				//});
				var intersection = intersects[ 0 ],
					obj = intersection.object;
					//obj.material.opacity = 0.7;

				//console.log(obj.username);
				//console.log(obj.name);
				if(obj.type == 'ringMonth')
				{
					selectedObject = obj;	
					showMonthDetails(obj);
				}
				else if(obj.type == 'project')
				{
					selectedObject = obj;	
					showProjectDetails(obj);
				}
				else if(obj.type == 'contributor')
				{
					selectedObject = obj;	
					showContributorDetails(obj);
				}				
				else if(obj.type == 'text')
				{
					selectedObject = plane;	
					showSelectedTextDetails(obj);
				}				
				
				if(!obj.type)
				{
					obj = plane;
					selectedObject = obj;	
					controls.newCenter = new THREE.Vector3(0, 0, 0);
				}
							
			}
			else if(intersects.length <= 0)
			{
				selectedObject.children.forEach(function( ring ) {
					ring.material.color.set( ring.actualColor );
					//ring.material.opacity = 0.7;
				});
				selectedObject = selectedObject.parent;
				selectedObject.children.forEach(function( child ) {
					child.fadeOut = false;
				});
				
				if(!selectedObject.type)
				{
					changeView('MAIN_VIEW');
					
					controls.center = new THREE.Vector3(0, 0, 0);
					
					ringTimeLine.forEach(function(element) {
						element.fadeOut = false;
						element.children.forEach(function(child) {
							child.fadeOut = false;
						});
					});
				}	
			} 

		}
		
		function onMouseMove( e ) {

			mouseVector.x = 2 * (e.clientX / WIDTH) - 1;
			mouseVector.y = 1 - 2 * ( e.clientY / HEIGHT );

			var raycaster = projector.pickingRay( mouseVector.clone(), camera ),
				intersects = raycaster.intersectObjects( selectedObject.children );
			
			//var currentColor = selectedObject.children[0].material.color;
			//for( var i = 0; i < intersects.length; i++ ) {
			if(intersects.length > 0)
			{
				var intersection = intersects[ 0 ],
					obj = intersection.object;

				if(selectedObject.children)
				{
					selectedObject.children.forEach(function( ring ) {
						//console.log(plane.children[1].length);
						ring.material.color.set( ring.actualColor );
					});
				} 
				obj.material.color.setRGB( 1.0, 0, 0 );
				//console.log(obj.id);
			}

		}
		

		var textCityName = new THREE.TextGeometry( 'GitHub City Visualization', { 
			size: 8,
			height: 2,
			curveSegments: 2,
			font: "helvetiker" });

		var textColor = 0x7C1771;
		var textMaterial = new THREE.MeshBasicMaterial( { color: textColor, transparent: true } );
		textIntro1 = new THREE.Mesh( textCityName, textMaterial );
		textIntro1.actualColor = textColor;
		//textIntro1.position.y = -10;
		textIntro1.position.z = 5000;
		textIntro1.type = 'text';
		scene.add(textIntro1);
		
		//console.log(cylinderArray2.length);
		// Add OrbitControls so that we can pan around with the mouse.
		controls = new THREE.OrbitControls(camera, renderer.domElement);
		//controls = new THREE.TrackballControls(camera, renderer.domElement);
		controls.maxPolarAngle = Math.PI/2;
		//controls.center = new THREE.Vector3(0, 0, 1000);
		//controls.target.set( 1000, 0, 0 );
		
		
		animate();
	
    }
	
	function showMonthDetails(ring)
	{
		changeView('RING_VIEW');	
		//ring.position.z += 20;
		//ring.scale.x = ring.scale.y = 20;
		
		infoUI.innerHTML = 'Showing details for ' + monthLookup[ring.id.substring(5, 7)] + ' ' + ring.id.substring(0, 4);
			
		ringTimeLine.forEach(function(element) {
			element.fadeOut = true;
			element.children.forEach(function(child) {
				child.fadeOut = true;
			});
		});
		ring.fadeOut = false;
		ring.children.forEach(function(child) {
			child.fadeOut = false;
		});
		
		textRingIds.forEach(function(text) {
			if(ring.id != text.id)
			{
				text.fadeOut = true;
			}
			else
			{
				text.fadeOut = false;
			}
		});
		
		textYears.forEach(function(text) {
			if(ring.id.substring(0, 4) != text.id)
			{
				text.fadeOut = true;
			}
			else
			{
				text.fadeOut = false;
			}
			
		});
		
		controls.newCenter = new THREE.Vector3(0, 0, 0);
		MOVE_ORBIT_CONTROLS = true;
	}
	
	function showProjectDetails(project)
	{
		changeView('PROJECT_VIEW');	
		
		/*
		var textProjectInfo = new THREE.TextGeometry( project.name + '--' + project.created_at, { 
			size: 8,
			height: 2,
			curveSegments: 2,
			font: "helvetiker" });
		
		var textColor = 0x7C1771;
		var textMaterial = new THREE.MeshBasicMaterial( { color: textColor, transparent: true } );
		text = new THREE.Mesh( textProjectInfo, textMaterial );
		text.actualColor = textColor;
		
		text.rotation.y = Math.PI / 2;
		//text.position = project.position.clone();
		//console.log(project.position);
		text.id = 'projectInfo';
		text.position.x = project.position.x + 10;
		text.position.z = -project.position.y;
		text.type = 'text';
		textProjectInfoArray.forEach(function(t1) {
			scene.remove(t1);
		});
		textProjectInfoArray = [];
		textProjectInfoArray.push(text);
		scene.add(text);
		
		//controls.center = new THREE.Vector3(text.position.x,text.position.y,text.position.z);
		//moveOrbitControls(text);
			
		controls.newCenter = text.position.clone();
		MOVE_ORBIT_CONTROLS = true;
		*/
			
		//controls.newCenter = text.position.clone();
		controls.newCenter = new THREE.Vector3(project.position.x + 10, project.position.z + project.scale.y, -project.position.y);
		MOVE_ORBIT_CONTROLS = true;
		
		var parent = project.parent;
		parent.children.forEach(function(child) {
			child.fadeOut = true;
		});
		project.fadeOut = false;
		project.textObject.fadeOut = false;
		
		var ps = particles.length;			
		while(ps--)
		{
			var contributor = particles[ps];
			//var p1 = contributor.position.clone();
			//var p2 = camera.position.clone();
			//contributor.scale.x = contributor.scale.y = p1.distanceTo(p2)/200;
			//contributor.scale.x = contributor.scale.y = (new THREE.Vector3()).subVectors(camera.position,contributor.position);
			contributor.addedToScene = false;			
		}
		
		infoUI.innerHTML = project.name + ' created on ' + project.created_at + '\nContributors: ';
		
		for(var i = 0; i < project.allContributors.length; i++)
		{			
			var contributor1 = project.allContributors[i];
			contributor1.addedToScene = true;				
			
			//console.log(contributor.username);
			var target = project;
			contributor1.destination = target;
			contributor1.destinationReached = false;
			
			contributor1.assignedTarget = true;
			if(contributor1.assignedTarget)
			{
				contributor1.position.x += (target.position.x - contributor1.position.x) * .2;
				contributor1.position.y += (target.position.y - contributor1.position.y) * .2;
				contributor1.position.z += (Math.random() * target.scale.y - contributor1.position.z) * .2;
				//contributor.position.z += (target.position.z - contributor.position.z) * .2;
			}
			
			infoUI.innerHTML += contributor1.username + ', ';
			
		}
	}
	
	function showContributorDetails(contributor1)
	{
		changeView('USER_VIEW');		
		//console.log(contributor1.username);
		
		var ps = particles.length;			
		while(ps--)
		{
			var contributor = particles[ps];
			//var p1 = contributor.position.clone();
			//var p2 = camera.position.clone();
			//contributor.scale.x = contributor.scale.y = p1.distanceTo(p2)/200;
			//contributor.scale.x = contributor.scale.y = (new THREE.Vector3()).subVectors(camera.position,contributor.position);
			contributor.addedToScene = false;			
		}
		
		contributor1.addedToScene = true;	
		
		//controls.newCenter = contributor1.position.clone();
		controls.newCenter = new THREE.Vector3(contributor1.position.x, contributor1.position.z, -contributor1.position.y);
		MOVE_ORBIT_CONTROLS = true;
		
		cylinderArray2.forEach(function(project) {
			parent = project.parent;
			
			parent.fadeOut = true;
			project.fadeOut = true;
		});
		
		infoUI.innerHTML = contributor1.username + ' worked on following projects: ';
		
		//show only the projects that the contributor worked on
		contributor1.allProjects.forEach(function(project) {
			parent = project.parent;
			//console.log(project.name);
			parent.fadeOut = false;
			project.fadeOut = false;
			
			infoUI.innerHTML += project.name + ', ';
		});		
	}
	
	
	function showSelectedTextDetails(selectedText)
	{
		textRingIds.forEach(function(text) {
			if(selectedText.id == text.id)
			{
				infoUI.innerHTML = 'loading data...';
				resetToBeginning();
				jumpToDate = selectedText.id + "-01";
				GO_TO_DATE = true;
			}
		});
		
		textYears.forEach(function(text) {
			if(selectedText.id == text.id)
			{
				infoUI.innerHTML = 'loading data...';
				resetToBeginning();
				jumpToDate = selectedText.id + "-01-01";
				GO_TO_DATE = true;
			}
		});
	}
	
	function moveOrbitControls()
	{
		var target = controls.newCenter;
		var currentPosition = controls.center;
		if((Math.abs(currentPosition.x - target.x) < 0.2) && (Math.abs(currentPosition.y - target.y) < 0.2))
		{
			MOVE_ORBIT_CONTROLS = false;		
			currentPosition.x = target.x;
			currentPosition.y = target.y;
			currentPosition.z = target.z;
		}
		else
		{
			currentPosition.x += (target.x - currentPosition.x) * .05;
			currentPosition.y += (target.y - currentPosition.y) * .05;
			//contributor.z += (target.scale.y + 10 - contributor.z) * .2;
			currentPosition.z += (target.z - currentPosition.z) * .05;
		}
		controls.center = new THREE.Vector3(currentPosition.x,currentPosition.y,currentPosition.z);
		zoomInCamera(controls.center);
	}
	
	function zoomInCamera(center)
	{
		if((center.x != 0) || (center.y != 0) || (center.z != 0))
		{
			if(Math.abs(camera.position.x - center.x) > 50)
			{
				var speed = (camera.position.x - center.x)/10;
				if(speed > 10)
					camera.position.x -= speed;
				else				
					camera.position.x -= speed;
			}
			if(Math.abs(camera.position.y - center.y) > 150)
			{
				var speed = (camera.position.y - center.y)/10;
				if(speed > 10)
					camera.position.y -= speed;
				else				
					camera.position.y -= speed;
			}
			if(Math.abs(camera.position.z - center.z) > 50)
			{
				var speed = (camera.position.z - center.z)/10;
				if(speed > 10)
					camera.position.z -= speed;
				else				
					camera.position.z -= speed;
			}
		}
		else
		{
			var speed = 15;
			if(camera.position.x < zoomOutDistance[0])
				camera.position.x += speed;		
				
			if(camera.position.y < zoomOutDistance[1])
				camera.position.y += speed;		
				
			if(camera.position.z < zoomOutDistance[2])
				camera.position.z += speed;			
		}
	}
	
	function changeView(view)
	{	
		MAIN_VIEW = false;
		RING_VIEW = false;
		USER_VIEW = false;
		PROJECT_VIEW = false;
		
		if(view == 'MAIN_VIEW')
		{
			MAIN_VIEW = true;
		}
		else if(view == 'RING_VIEW')
		{
			RING_VIEW = true;
		}
		else if(view == 'PROJECT_VIEW')
		{
			PROJECT_VIEW = true;
		}
		else if(view == 'USER_VIEW')
		{
			USER_VIEW = true;			
		}
	}
	
	function addContributors()
	{	
		// now set up the particle material
		var DENSITY = 10;
		var particlesGeometry = new THREE.SphereGeometry( 1, 12, 12 );
		//var geometry	= new THREE.Geometry();
		
		//camera.position.x = 
		
		for(var cNum = 0; cNum < contributorInfo.length; cNum++)
		{
			var color;
			
			if(contributorInfo[cNum].type == -1)
			{
				color = 'orange';
			}
			else
			{
				color = 'green';
			}
						
			//var material = new THREE.ParticleSystemMaterial( { map: THREE.ImageUtils.loadTexture("particle.png"), size: 10, transparent: true, blending: THREE.AdditiveBlending, opacity: USER_OPACITY} );
			// we make a particle material and pass through the 
			// colour and custom particle render function we defined. 
			//var material = new THREE.ParticleCanvasMaterial( { color: 0xffffff, program: particleRender } );
			// make the particle
			var material = new THREE.MeshBasicMaterial( {color: 0xffff00, transparent: true, opacity: USER_OPACITY} );
			var contributor = new THREE.Mesh( particlesGeometry, material );
			//scene.add( sphere );
			//var contributor = new THREE.Particle(material);
			contributor.material.color.set(color);
			contributor.actualColor = color;
			contributor.username = contributorInfo[cNum].username;
			contributorNames.push(contributor.username);
			// give it a random x and y position between -500 and 500
			contributor.position.set(0, 0, 5);
			if(contributorInfo[cNum].type == -1)
			{
				contributor.position.set(3500, 3500, 5);
			}
			// scale it up a bit
			//contributor.scale.x = contributor.scale.y = 10;
	 
			// and to the array of particles. 
			particles.push(contributor); 
			// add it to the scene
			plane.add( contributor );
	 	}	    
		// add some additional vars to the
		// particles to ensure we can do physics
		// and so on
		var ps = particles.length;
		while(ps--)
		{
			var contributor 		= particles[ps];
			contributor.assignedTarget = false;
			contributor.destinationReached = false;
			contributor.addedToScene = false;
			contributor.destination = new THREE.Vector3();
			contributor.angle = 0;
			contributor.directionIndicator = 1;
			contributor.type = 'contributor'
			contributor.allProjects = [];
		}
	}
	
	
	/**
	 * Updates the velocity and position
	 * of the particles in the view
	 */
	 
	function updateContributors()
	{
		var ps = particles.length;	
		
		while(ps--)
		{
			var contributor = particles[ps];
			var p1 = contributor.position.clone();
			var p2 = camera.position.clone();
			if(contributor.scale.x <= 20)
			{
				contributor.scale.x = contributor.scale.y = contributor.scale.z = p1.distanceTo(p2)/700;
			}
			else
			{
				contributor.scale.x = contributor.scale.y = contributor.scale.z = 20;
			}
			
			if(contributor.scale.x >= 4)
			{
				contributor.scale.x = contributor.scale.y = contributor.scale.z = p1.distanceTo(p2)/700;
			}
			else
			{
				contributor.scale.x = contributor.scale.y = contributor.scale.z = 4;
			}
			//contributor.scale.x = contributor.scale.y = (new THREE.Vector3()).subVectors(camera.position,contributor.position);
			
			if(contributor.username == repoInfo[repoCounter].username)
			{
				//plane.add( contributor );
				contributor.addedToScene = true;
				
				
				//console.log(contributor.username);
				var target = cylinderArray[repoInfo[repoCounter].repo];
				contributor.destination = target;
				contributor.destinationReached = false;
				
				if(!contains(target.allContributors, contributor))
				{
					target.allContributors.push(contributor);
				}
				
				if(!contains(contributor.allProjects, target))
				{
					contributor.allProjects.push(target);
				}
				
				contributor.assignedTarget = true;
				if(contributor.assignedTarget)
				{
					//contributor.velocity 	= new THREE.Vector3();
					//contributor.position.x += (contributor.origPos.x - contributor.position.x) * .2;
					//contributor.position.y += (contributor.origPos.y - contributor.position.y) * .2;
					//contributor.position.z += (contributor.origPos.z - contributor.position.z) * .2;
					contributor.position.x += (target.position.x - contributor.position.x) * .2;
					contributor.position.y += (target.position.y - contributor.position.y) * .2;
					contributor.position.z += (target.scale.y + 10 - contributor.position.z) * .2;
					//contributor.position.z += (target.position.z - contributor.position.z) * .2;
				}
			}
			else
			{
				revolveAroundProject(contributor);
			}
		}		
	}
	
	function updateContributorsGoTo()
	{
		var ps = particles.length;	
		
		while(ps--)
		{
			var contributor = particles[ps];
			
			if(contributor.username == repoInfo[repoCounter].username)
			{
				//plane.add( contributor );
				contributor.addedToScene = true;				
				
				//console.log(contributor.username);
				var target = cylinderArray[repoInfo[repoCounter].repo];
				contributor.destination = target;
				contributor.destinationReached = false;
				
				if(!contains(target.allContributors, contributor))
				{
					target.allContributors.push(contributor);
				}
				
				if(!contains(contributor.allProjects, target))
				{
					contributor.allProjects.push(target);
				}				
			}
		}		
	}
		
	function updateSelectedContributors(project)
	{		
		if(project.type == 'project')
		{
			for(var i = 0; i < project.allContributors.length; i++)
			{
				revolveAroundProject(project.allContributors[i]);
			}		
		}
	}
	
	function revolveAroundProject(contributor)
	{
		if(contributor.assignedTarget)
		{					
			if(Math.abs(contributor.position.x - contributor.destination.position.x) < 0.2)
			{
				//console.log(contributor.destinationReached);
				//contributor.position.x = contributor.destination.position.x;
				//contributor.position.y = contributor.destination.position.y;
				//contributor.position.z = contributor.destination.scale.y + 10 + (Math.random() * 50) - contributor.position.z) * .2;
				contributor.destinationReached = true;
			}
			
				//console.log(contributor.destinationReached);
			if(contributor.destinationReached)
			{
				contributor.position.x = contributor.destination.position.x + 10 * Math.cos(contributor.angle);
				contributor.position.y = contributor.destination.position.y + 10 * Math.sin(contributor.angle);
				if(contributor.position.z > contributor.destination.scale.y + 5)
				{
					contributor.directionIndicator = -1;
					contributor.position.z = contributor.destination.scale.y + 5;
				}
				if(contributor.position.z < 5)
				{
					contributor.directionIndicator = 1;
				}
				contributor.position.z += contributor.directionIndicator/5;
				//angleContributor += STEP;
				contributor.angle += 2 * STEP;
			}
			else
			{
				contributor.position.x += (contributor.destination.position.x - contributor.position.x) * .2;
				contributor.position.y += (contributor.destination.position.y - contributor.position.y) * .2;
				//contributor.position.z += (contributor.destination.scale.y + 10 + (Math.random() * 10) - contributor.position.z) * .2;
			}
			
			//contributor.position.x += (contributor.destination.position.x - contributor.position.x) * .2;
			//contributor.position.y += (contributor.destination.position.y - contributor.position.y) * .2;
			//contributor.position.z += (contributor.destination.scale.y + 10 + (Math.random() * 50) - contributor.position.z) * .2;
		}
	}

	function generateTexture() {

		var canvas = document.createElement( 'canvas' );
		canvas.width = 32;
		canvas.height = 64;

		var context = canvas.getContext( '2d' );
		context.fillStyle = '#ffffff';
		context.fillRect( 0, 0, 32, 128 );

		for ( var y = 2; y < 128; y += 2 ) {

			for ( var x = 0; x < 64; x += 2 ) {

				var value = Math.floor( Math.random() * 128 );
				context.fillStyle = 'rgb(' + [ value, value, value ].join( ',' )  + ')';
				context.fillRect( x, y, 2, 1 );
			}
		}

		var canvas2 = document.createElement( 'canvas' );
		canvas2.width = 512;
		canvas2.height = 1024;

		var context = canvas2.getContext( '2d' );
		context.imageSmoothingEnabled = false;
		context.webkitImageSmoothingEnabled = false;
		context.mozImageSmoothingEnabled = false;
		context.drawImage( canvas, 0, 0, canvas2.width, canvas2.height );

		return canvas2;

	}
	
	function increaseProjectHeight(project, height)
	{
	}
	
	function resetToBeginning()
	{
		initialRepoData.forEach(function(project) {
			if(HEIGHT_LINESOFCODE)
			{
				cylinderArray[project.repo].height = HEIGHT_NORMALIZER + (project.initialSize) / 100;
			}
			else if(HEIGHT_COMMITS)
			{
				cylinderArray[project.repo].height = HEIGHT_NORMALIZER + 1;
			}
		});
							
		particles.forEach(function(contributor) {
			contributor.addedToScene = false;
		});
		
		ringNum = 0;
		//ringNumInitial = 0;
		repoCounter = 0;
	}
	
	function goToDate()
	{		
		for(var rc = repoCounter; rc < repoInfo.length; rc++)
		{
			if(parseInt(repoInfo[rc].timestamp.substring(0,4)) < parseInt(jumpToDate.substring(0,4)))
			{
				for(var k = 0; k < cylinderArray2.length; k++)
				{
					if((cylinderArray2[k].name == repoInfo[rc].repo))
					{
						if(HEIGHT_LINESOFCODE)
						{
							if(cylinderArray2[k].height >= HEIGHT_NORMALIZER)
							{
								cylinderArray2[k].height += repoInfo[rc].contribution / 100;
							}
							else
							{
								cylinderArray2[k].height = HEIGHT_NORMALIZER;
							}
						}
						else if(HEIGHT_COMMITS)
						{
							cylinderArray2[k].height += 1;
						}
					}
				}
			}			
			else if((parseInt(repoInfo[rc].timestamp.substring(0,4)) == parseInt(jumpToDate.substring(0,4))) && 
			(parseInt(repoInfo[rc].timestamp.substring(5,7)) < parseInt(jumpToDate.substring(5,7))))
			{
				for(var k = 0; k < cylinderArray2.length; k++)
				{
					if((cylinderArray2[k].name == repoInfo[rc].repo) && rc < repoInfo.length - 1)
					{
						if(HEIGHT_LINESOFCODE)
						{
							if(cylinderArray2[k].height >= HEIGHT_NORMALIZER)
							{
								cylinderArray2[k].height += repoInfo[rc].contribution / 100;
							}
							else
							{
								cylinderArray2[k].height = HEIGHT_NORMALIZER;
							}
						}
						else if(HEIGHT_COMMITS)
						{
							cylinderArray2[k].height += 1;
						}
					}
				}
			}
			else
			{
				repoCounter = rc - 1;
				break;
			}
			
			updateContributorsGoTo();
		}
		GO_TO_DATE = false;
	}
	
    // Renders the scene and updates the render as needed.
    function animate() {

		// Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
		requestAnimationFrame(animate);
		
		//camera.position.x = particles[4].position.x;
		//camera.position.y = particles[4].position.z;
		//camera.position.z = particles[4].position.y + 2;
		//console.log(cylinderArray2[repoCounter].allContributors.length);
		// Layout the city rapidly
		//if(circle.scale.x < 2 * ringTimeLine[ringNum].outerRadius)
		if(INTRO_SEQUENCE)
		{
			if(camera.position.z > 5000)
			{
				camera.position.z -= 1;				
			}
			else if(camera.position.z > 2000)
			{
				camera.position.z -= 10;
				if(camera.position.z > 0)
				{
					camera.position.x += 12;				
					camera.position.y += 5;
				}
				/*else
				{
					camera.position.x -= 20;				
					camera.position.y -= 7.5;
				}
				*/

				changeView('MAIN_VIEW');
			}
			else
			{
				INTRO_SEQUENCE = false;
				
				var textDemo1 = new THREE.TextGeometry( 'What am I looking at?', { 
					size: 24, height: 6, curveSegments: 2, font: "helvetiker" });
				
				var textColor = 0x7C1771;
				var textMaterial = new THREE.MeshBasicMaterial( { color: textColor, transparent: true } );
				textDemo = new THREE.Mesh( textDemo1, textMaterial );
				textDemo.actualColor = textColor;

				textDemo.id = 'textDemo';
				//textDemo.position.x = 2700;
				textDemo.position.y = 2900;
				//textDemo.position.z = -20;
				textDemo.rotation.x = Math.PI / 2;
				textDemo.rotation.y = Math.PI;
				textDemo.type = 'text';
				plane.add(textDemo);
			}
			
						
			if(camera.position.z < 4000)
			{
				scene.remove(textIntro1);
				//scene.remove(textIntro2);
				//scene.remove(textIntro3);
			}	
			else if(camera.position.z < 5500)
			{
				//scene.add(textIntro3);
			}	
			else if(camera.position.z < 6000)
			{
				//scene.add(textIntro2);
			}	
		}
		
		if(GO_TO_DATE)
		{
			goToDate();
		}
		else if(MAIN_VIEW)
		{
			if(circle.scale.x < 5800)
			{
				circle.scale.x += 10;
				circle.scale.y += 10;
				
				//if(((circle.scale.x % 10) == 0) && (circle.scale.x / 2 % RINGRADIUS) == 0)
				//console.log(circle.scale.x / 2 % RINGRADIUS);
				if(Math.floor(circle.scale.x / 2 % RINGRADIUS) == 0 && ringNumInitial < TOTAL_RINGS)
				{
					plane.add(ringTimeLine[ringNumInitial]);
					plane.add(textRingIds[ringNumInitial]);
					if(ringNumInitial % 12 == 0)
					{
						plane.add(textYears[ringNumInitial/12]);	
						//console.log(ringNumInitial/12);					
					}
					
					for(var i = 0; i < ringTimeLine[ringNumInitial].children.length; i++)
					{
						//ringTimeLine[ringNumInitial].children[i].material.opacity = 1;
						ringTimeLine[ringNumInitial].children[i].addedToScene = true;
					}
					//console.log(ringTimeLine[ringNumInitial].children.length);
					ringNumInitial++;
				}
				
				if(ringNumInitial == TOTAL_RINGS)
				{
					ringNumInitial++;
					
					//textYears.forEach(function(text) {
					//	plane.add(text);
					//});
					
					//textRingIds.forEach(function(text) {
					//	plane.add(text);
					//});
					//jumpToDate = "2009-07-11";
					//GO_TO_DATE = true;
				}
			}
			
			if(repoCounter == repoInfo.length - 1)
			{
				console.log('done');
				
				//resetToBeginning();
				//jumpToDate = "2007-06-19";
				//GO_TO_DATE = true;
			}
			
			updateContributors();
				
			ringTimeLine.forEach(function(ring) {
				if((repoInfo[repoCounter].timestamp.substring(0,7) == ring.id))
				{			
					//scene.add(ringTimeLine[ringNum]);
					//ring.material.color.set(0x159A8F);
					ring.actualColor = 0x159A8F;
					
					//console.log(ringTimeLine[ringNum].id);
					//ringNum++;
					currentTimePeriod = ring.id + "-01";
					infoUI.innerHTML = 'Showing activity for ' + monthLookup[ring.id.substring(5, 7)] + ' ' + ring.id.substring(0, 4);
				}
				else
				{
					//ring.material.color.set(ring.yearColor);
					ring.actualColor = ring.yearColor;
					//ringNum++;					
				}
			});
			
			for(var k = 0; k < cylinderArray2.length; k++)
			{
				if((cylinderArray2[k].name == repoInfo[repoCounter].repo) && repoCounter < repoInfo.length - 1)
				{
					if(HEIGHT_LINESOFCODE)
					{
						if(cylinderArray2[k].height >= HEIGHT_NORMALIZER)
						{
							cylinderArray2[k].height += repoInfo[repoCounter].contribution / 100;
							repoCounter++;
						}
						else
						{
							cylinderArray2[k].height = HEIGHT_NORMALIZER;
						}
					}
					else if(HEIGHT_COMMITS)
					{
						cylinderArray2[k].height += 1;
						repoCounter++;
					}
				}
			}
			//cylinder2.height = repoInfo[i].contribution;

			//angleSun += Math.random() * 10 * STEPSUN;					
			
			//keep camera above ground
			if(camera.position.y > 1000)
			{
				ring.position.y = 15;
				ground.position.y = -350;
			}
			else if(camera.position.y > 500)
			{
				ring.position.y = 5;
				ground.position.y = -150;
			}
			else if(camera.position.y < 500)
			{
				ring.position.y = 1;
				ground.position.y = -80;
			}
			
			for(var i=0; i < cylinderArray2.length; i++)
			{
				if((cylinderArray2[i].addedToScene == true) && (cylinderArray2[i].scale.y < cylinderArray2[i].height))
				{
					if((cylinderArray2[i].height - cylinderArray2[i].scale.y) >= 25)
						cylinderArray2[i].scale.y += 25;
					else
						cylinderArray2[i].scale.y += (cylinderArray2[i].height - cylinderArray2[i].scale.y);
				}
				else if((cylinderArray2[i].addedToScene == true) && (cylinderArray2[i].scale.y > cylinderArray2[i].height))
				{				
					if((cylinderArray2[i].scale.y - cylinderArray2[i].height) >= 25)
						cylinderArray2[i].scale.y -= 25;
					else
						cylinderArray2[i].scale.y -= (cylinderArray2[i].scale.y - cylinderArray2[i].height);
				}
				else
				{
					//cylinderArray2[i].material.color.set(cylinderArray2[i].actualColor);
				}
				
				// update the height of text object
				cylinderArray2[i].textObject.position.z = cylinderArray2[i].scale.y + 5;
			}
			//sun.position.z = light.position.z = 4000 * Math.sin(angleSun/100);
			//sun.position.x = light.position.x = 4000 * Math.cos(angleSun/100);
			//console.log(sun.position.y);
						
			//reset contributors to visible			
			var ps = particles.length;			
			while(ps--)
			{
				var contributor = particles[ps];
				//var p1 = contributor.position.clone();
				//var p2 = camera.position.clone();
				//contributor.scale.x = contributor.scale.y = p1.distanceTo(p2)/200;
				//contributor.scale.x = contributor.scale.y = (new THREE.Vector3()).subVectors(camera.position,contributor.position);
				contributor.addedToScene = true;			
			}
		}
		else if(RING_VIEW)
		{
			ringTimeLine.forEach(function(element) 
			{
				if(element.fadeOut == true)
				{
					if(element.material.opacity > DISABLE_OPACITY)
						element.material.opacity -= 0.05;
				}
				else
				{
					if(element.material.opacity < RING_OPACITY)
						element.material.opacity += 0.05;
				}
				
				element.children.forEach(function(child) {					
					if(child.fadeOut == true)
					{
						if(child.material.opacity > DISABLE_OPACITY)
							child.material.opacity -= 0.05;
					}
					else
					{
						if(child.material.opacity < PROJECT_OPACITY)
							child.material.opacity += 0.05;
					}
				});
			});			
		}
		else if(PROJECT_VIEW)
		{
			var parent = selectedObject.parent;
			parent.children.forEach(function(child) {
				if(child.fadeOut == true)
				{
					if(child.material.opacity > DISABLE_OPACITY)
						child.material.opacity -= 0.05;
				}
				else
				{
					if(child.material.opacity < PROJECT_OPACITY)
						child.material.opacity += 0.05;
				}
			});
			
			updateSelectedContributors(selectedObject);
		}
		else if(USER_VIEW)
		{
		
		}
		
		if(MOVE_ORBIT_CONTROLS == true)
		{
			moveOrbitControls();		
		}
		
		var ps = particles.length;			
		while(ps--)
		{
			var contributor = particles[ps];
			if(contributor.addedToScene == true)
			{
				contributor.visible = true;
			}
			else
			{
				contributor.visible = false;
			}
		}			
		
		ringTimeLine.forEach(function(element) {
			if(element.fadeOut == true)
			{
				if(element.material.opacity > DISABLE_OPACITY)
					element.material.opacity -= 0.05;
			}
			else
			{
				if(element.material.opacity < RING_OPACITY)
					element.material.opacity += 0.05;
			}
			
			element.children.forEach(function(child) {					
				if(child.fadeOut == true)
				{
					if(child.material.opacity > DISABLE_OPACITY)
						child.material.opacity -= 0.05;
				}
				else
				{
					if(child.material.opacity < PROJECT_OPACITY)
						child.material.opacity += 0.05;
				}
			});
		});
		
			
		plane.children.forEach(function(element) {
			if(element.type == 'text')
			{
				if(element.fadeOut == true)
				{
					if(element.material.opacity > DISABLE_OPACITY)
						element.material.opacity -= 0.05;
				}
				else
				{
					if(element.material.opacity < PROJECT_OPACITY)
						element.material.opacity += 0.05;
				}			
			}
		});
		
		textYears.forEach(function(textYear) {
			var threshold = 4000;
			var twice = 2 * threshold;
			if((camera.position.x > twice) || (camera.position.x < -twice) || (camera.position.y > twice) || (camera.position.y < -twice) ||
			(camera.position.z > twice) || (camera.position.z < -twice))
			{
				textYear.setScale = 5;
				//textYear.scale.x = 5;
				//textYear.scale.y = 5;
			}
			else if((camera.position.x > threshold) || (camera.position.x < -threshold) || (camera.position.y > threshold) || 
			(camera.position.y < -threshold) || (camera.position.z > threshold) || (camera.position.z < -threshold))
			{
				textYear.setScale = 3;
				//textYear.scale.x = 3;
				//textYear.scale.y = 3;
			}
			else
			{
				textYear.setScale = 1;
				//textYear.scale.x = 1;
				//textYear.scale.y = 1;
			}
			
			if(textYear.scale.x < textYear.setScale)
			{
				textYear.scale.x = textYear.scale.y += 0.1;
			}
			if(textYear.scale.x > textYear.setScale)
			{
				textYear.scale.x = textYear.scale.y -= 0.1;
			}
		});
		
		var delta = clock.getDelta();
		controls.update( delta );
		
		// Render the scene.
		renderer.clear();
		//composer.render( 0.1 );
		renderer.render(scene, camera);

    }

	function mainVariableChanged()
	{		
		var dropDownItem = document.getElementById("mainVariable");
		if(dropDownItem.value == "commits")
		{
			HEIGHT_COMMITS = true;
			HEIGHT_LINESOFCODE = false;
		}
		else if(dropDownItem.value == "linesofcode")
		{
			HEIGHT_COMMITS = false;
			HEIGHT_LINESOFCODE = true;
		}

		infoUI.innerHTML = 'loading data...';
		resetToBeginning();
		jumpToDate = currentTimePeriod + "-01";
		GO_TO_DATE = true;
	}
  </script>
  
	<script>
	  $(function() {
		$( "#userNameSearch" ).autocomplete({
		  source: contributorNames
		});
		
		$( "#projectNameSearch" ).autocomplete({
		  source: projectNames
		});
		
		$( "#projectLanguageSearch" ).autocomplete({
		  source: projectLanguages
		});
		
		$("#userNameSearch").keyup(function(event){
			if(event.keyCode == 13){	
				var uName = $(this).val();
				
				var ps = particles.length;			
				while(ps--)
				{
					var contributor = particles[ps];
					if(uName == contributor.username)
					{
						selectedObject = contributor;	
						showContributorDetails(contributor);
						break;
					}
				}
			}
		});
		
		$("#projectNameSearch").keyup(function(event){
			if(event.keyCode == 13){	
				var pName = $(this).val();
				
				var pj = cylinderArray2.length;			
				while(pj--)
				{
					var project = cylinderArray2[pj];
					if(pName == project.name)
					{
						var ring = project.parent;
						selectedObject = ring;	
						showMonthDetails(selectedObject);
						
						selectedObject = project;	
						showProjectDetails(selectedObject);
						break;
					}
				}
			}
		});
		
		$("#projectLanguageSearch").keyup(function(event){
			if(event.keyCode == 13){	
				var lName = $(this).val();
				
				ringTimeLine.forEach(function(ring) {
					ring.fadeOut = true;
				});
				
				var pj = cylinderArray2.length;			
				while(pj--)
				{
					var project = cylinderArray2[pj];
					var ring = project.parent;
					project.fadeOut = true;
					project.textObject.fadeOut = true;
					if(lName == project.language)
					{
						project.fadeOut = false;
						project.textObject.fadeOut = false;
						ring.fadeOut = false;
					}
				}
			}
		});
	  });
	  </script>
	  <div class = "lbl">
		  <div id = "infoUI2">
			Height is: 
			<select id="mainVariable" onChange="mainVariableChanged()">
				<option value="commits" selected="selected">Commits</option>
				<option value="linesofcode">Lines of Code</option>
			</select>
		  </div>
		  <div id="infoUI3">
			Search:
			<input id="userNameSearch" type="text" placeholder="User Name">
			<input id="projectNameSearch" type="text" placeholder="Project Name">
			<input id="projectLanguageSearch" type="text" placeholder="Language">
		  </div>
		  <div id = "infoUI1">
		  </div>
	  </div>
	  <div id = "infoUI" class = "lbl1">
	  </div>

</body>
</html>
